<html>
	<head>
		<style>
			body {
				background-color: #000000;
				color: #FFFFFF;
			}
			#control {
				visibility: hidden;
			}
			#count-controls {
				width: 50%;
			}
			#container {
				height: 100%;
			}
			.control {
				margin: 30px 20px 10px;
			    width: 180px;
			    height: 200px;
			    position: absolute;
			}
			.image {
				width: 175px;
				height: 175px;
			}
			.text-wrapper {
			    overflow: hidden;
			}
			.text {
			    text-overflow: ellipsis;
			    overflow: hidden;
			    white-space: pre;
			    color: #FFFFFF;
			    -webkit-transition-property: webkit-transform;
			    transition-timing-function: linear;
			    -webkit-transition-timing-function: linear;
			}
		</style>
		<script>
			function generateControls() {
				var screenWidth = window.innerWidth,
					screenHeight = window.innerHeight,
					controlsPerRow,
					container,
					count,
					control,
					controlTemplate,
					controlCount,
					image,
					status,
					idx;

			    container = document.getElementById('container');
			    controlCount = container.childNodes.length;
			    count = document.getElementById('count-controls').value;
			    status = document.getElementById('status');

			    if (count > controlCount) {
			    	controlTemplate = document.getElementById('control');
			    	controlsPerRow = Math.floor(screenWidth / controlTemplate.offsetWidth);
			    	for (idx=controlCount; idx<count; idx++) {
			    		control = controlTemplate.cloneNode(true);
					    image = control.getElementsByClassName('image')[0];
					    image.src = 'http://placehold.it/300x300/' + Math.floor(Math.random()*0x1000000).toString(16) + '/ffffff&text=Image ' + (idx+1);
					    control.id = 'control' + idx;
					    control.style['top'] = Math.floor(idx/controlsPerRow)*(controlTemplate.clientHeight) + 20 + 'px';
					    control.style['left'] = idx%controlsPerRow*controlTemplate.clientWidth + 'px';
					    container.appendChild(control);
			    	}
			    } else if (count < controlCount) {
			    	for (idx=controlCount-1; idx>=count; idx--) {
			    		container.removeChild(container.childNodes[idx]);
			    	}
			    }

				status.innerHTML = count + ' control' + (count!=1 ? 's' : '');
				controlCount = count;
			}

			function incrementControls() {
				var control = document.getElementById('count-controls');
				control.value = document.getElementById('container').childNodes.length + 1;
				control.onmouseup();
			}

			function decrementControls() {
				var control = document.getElementById('count-controls');
				control.value = document.getElementById('container').childNodes.length - 1;
				control.onmouseup();
			}

			function enter(inControl) {
				if (typeof currentJob !== 'undefined') clearTimeout(currentJob);
				var text = inControl.getElementsByClassName('text')[0];
				text.style.transitionDuration = '100s';
			    text.style.webkitTransitionDuration = '100s';
			    text.style.overflow = 'visible';
			    text.style.textOverflow = 'clip';
			    text.style.webkitTransform = 'translateZ(0) translateX(-' + text.scrollWidth + 'px)';
			}

			function leave(inControl) {
				var text = inControl.getElementsByClassName('text')[0];
				text.style.webkitTransitionDuration = '0s';
				text.style.overflow = 'hidden';
				text.style.textOverflow = 'ellipsis';
				text.style.webkitTransform = '';
			}
		</script>
	</head>
	<body onload="generateControls();">
		<div class="controls">
			<button onclick="decrementControls();">-</button>
		    <input type="range" id="count-controls" min=0 max=1000 value=100 onmouseup="generateControls();" />
		    <button onclick="incrementControls();">+</button>
		    <span id="status"></span>
		</div>
		<div id="container"></div>
		<div id="control" class="control" onmouseenter="enter(this);" onmouseleave="leave(this);">
		    <img class="image" />
	        <div class="text-wrapper">
	            <div class="text">This is a relatively long string that will be animated using a CSS transform, specifically translateX. When we place a number of sibling elements on the screen that are absolutely positioned, the number of elements that have to be repainted is very high, and somewhat proportional to the number of sibling elements that are absolutely positioned on screen. This can be solved by placing each of these controls into their own hardware-accelerated layer, but we need to figure out what the right balance between GPU offloading and CPU load when determining when and where to apply translateZ(0).</div>
	        </div>
		</div>
	</body>
</html>
